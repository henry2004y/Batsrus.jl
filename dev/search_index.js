var documenterSearchIndex = {"docs":
[{"location":"man/manual/#Examples","page":"Manual","title":"Examples","text":"","category":"section"},{"location":"man/manual/#IDL-format-output-loader","page":"Manual","title":"IDL format output loader","text":"Read data\n\nfile = \"1d_bin.out\";\nbd = load(file);\nbd = load(file, verbose=true);\nbd = load(file, npict=1);\n\n3D structured spherical coordinates\n\nfile = \"3d_structured.out\";\nbd = load(file, verbose=false);\n\nlog file\n\nlogfilename = \"shocktube.log\";\nhead, data = readlogdata(logfilename)","category":"section"},{"location":"man/manual/#Data-Extraction","page":"Manual","title":"Data Extraction","text":"Checking variable range\n\nget_var_range(bd, \"rho\")\n\nRaw variables\n\nNote that the variable names for queries must be in lowercase!\n\nρ = getvar(bd, \"rho\")\nbd[\"rho\"]\n\nExtracting data at a given location\n\nloc = Float32[0.0, 0.0] # The type determines the output type\nd = interp1d(bd, \"rho\", loc)\n\nExtracting data along a given line\n\npoint1 = Float32[-10.0, -1.0]\npoint2 = Float32[10.0, 1.0]\nw = interp1d(bd, \"rho\", point1, point2)\n\nbd[\"rho\"][X=-10 .. 10, Y=Near(0.0)]\n\nExtracting data using DimensionalData\n\nWe can also use Selectors from DimensionalData for extracting data. Note that the Selectors need to be imported from Batsrus.jl; alternatively you can simply using DimensionalData.\n\nbd[\"rho\"][X=At(0.0), Y=At(0.0)]\nbd[\"rho\"][X=-10 .. 10, Y=Near(0.5)]\nbd[\"rho\"][X=-10 .. 10, Y=-0.5 .. 0.5]\n\nDerived variables\n\nWe provide utility methods get_magnitude, get_magnitude2, and fill_vector_from_scalars for vector processing:\n\nBmag = get_magnitude(bd, :B)\nB2 = get_magnitude2(bd, :B)\nBvec = Batsrus.fill_vector_from_scalars(bd, :B)\npaniso0 = get_anisotropy(bd, 0)\n\nThese are built upon get_vectors. fill_vector_from_scalars is slower than get_vectors since it involves additional array allocations. Here is a full list of predefined derived quantities in get_vectors:\n\nDerived variable name Meaning Required variable\n:B Magnetic field vector Bx, By, Bz\n:E Electric field vector Ex, Ey, Ez\n:U Velocity vector Ux, Uy, Uz\n:U0 Electron velocity vector UxS0, UyS0, UzS0\n:U1 Proton velocity vector UxS1, UyS1, UzS1","category":"section"},{"location":"man/manual/#Output-format-conversion","page":"Manual","title":"Output format conversion","text":"We can convert 2D/3D BATSRUS outputs *.dat to VTK formats. It uses the VTK XML format writer writeVTK to generate files for Paraview and Tecplot. The default converted filename is out.vtu.\n\nASCII Tecplot file (supports both tec and tcp) and binary Tecplot file (set DOSAVETECBINARY=TRUE in BATSRUS PARAM.in):\n\nfile = \"x=0_mhd_1_n00000050.dat\"\nconvertTECtoVTU(file)\n\n3D structured IDL file (gridType=:vti returns image vti file, gridType=:vtr returns rectilinear vtr file, gridType=:vts returns structured vts file):\n\nfile = \"3d_structured.out\"\nconvertIDLtoVTK(file, gridType=:vti)\n\n3D unstructured IDL file together with header and tree file:\n\nfiletag = \"3d_var_1_n00002500\"\nconvertIDLtoVTK(filetag)\n\nnote: Note\nThe file suffix should not be provided for this to work correctly!\n\nMultiple files:\n\ndir = \"./\"\nfilenames = filter(file -> startswith(file, \"3d\") && endswith(file, \".dat\"), readdir(dir))\nfilenames = dir .* filenames\n\nfor filename in filenames\n   convertTECtoVTU(filename, filename[1:end-4])\nend\n\nProcessing multiple files with threads in parallel:\n\ndir = \"./\"\nfilenames = filter(file -> startswith(file, \"3d\") && endswith(file, \".dat\"), readdir(dir))\nfilenames = dir .* filenames\n\nThreads.@threads for filename in filenames\n   println(\"filename=$filename\")\n   convertTECtoVTU(filename, filename[1:end-4])\nend\n\nMore examples can be found in examples.","category":"section"},{"location":"man/manual/#HDF-format-output-loader","page":"Manual","title":"HDF format output loader","text":"filename = \"3d__var_1_n00006288.h5\"\nfile = BatsrusHDF5Uniform(filename)","category":"section"},{"location":"man/manual/#Field-extraction","page":"Manual","title":"Field extraction","text":"Variable var can be extracted in the whole domain:\n\nvar, (xl_new, yl_new, zl_new), (xu_new, yu_new, zu_new) = extract_var(file, \"bx\")\n\nwhere (xl_new, yl_new, zl_new) and (xu_new, yu_new, zu_new) return the lower and upper bound, respectively.\n\nVariables within a box region can be extracted as following:\n\nvar, (xl_new, yl_new, zl_new), (xu_new, yu_new, zu_new) =\n   extract_var(file, \"bx\"; xmin, xmax, ymin, ymax, zmin, zmax)","category":"section"},{"location":"man/manual/#Data-visualization","page":"Manual","title":"Data visualization","text":"We provide plot recipes for Plots.jl, Makie.jl, and wrappers for PyPlot.jl.\n\nThe recipes for Plots.jl and Makie.jl will work on all kinds of plots given the correct dimensions, e.g.\n\nusing Plots\n\nplot(bd, \"p\")\ncontourf(bd, \"Mx\", xlabel=\"x\")\n\nSee the official documentation for Plots.jl for more information.\n\nOn the other hand, most common 1D and 2D plotting functions are wrapped over their Matplotlib equivalences through PyPlot.jl. To trigger the wrapper, using PyPlot. Check out the documentation for more details.","category":"section"},{"location":"man/manual/#Quick-exploration-of-data","page":"Manual","title":"Quick exploration of data","text":"Using the same plotting functions as in Matplotlib is allowed, and actually recommended. This takes advantage of multiple dispatch mechanism in Julia. Some plotting functions can be directly called as shown below, which allows for more control from the user. using PyPlot to import the full capability of the package, etc. adding colorbar, changing line colors, setting colorbar range with clim.\n\nFor 1D outputs, we can use plot or scatter.\n\nline plot\n\nplot(bd, \"p\", linewidth=2, color=\"tab:red\", linestyle=\"--\", linewidth=2)\n\nscatter plot\n\nscatter(bd, \"p\")\n\nFor 2D outputs, we can select the following functions:\n\ncontour\ncontourf\nimshow\npcolormesh\nplot_surface\nplot_tricontour\nplot_tricontourf\nplot_trisurf\ntripcolor\n\nwith either quiver or streamplot. By default the linear colorscale is applied. If you want to switch to logarithmic, set argument colorscale=:log.\n\ncontour\n\ncontour(bd, \"p\")\n\nfilled contour\n\ncontourf(bd, \"p\")\ncontourf(bd, \"p\"; levels, plotrange=[-10,10,-Inf,Inf], plotinterval=0.1)\n\nsurface plot\n\nplot_surface(bd, \"p\")\n\ntriangle surface plot\n\nplot_trisurf(bd, \"p\")\n\ntriangle filled contour plot\n\ntricontourf(bd, \"p\")\n\nstreamline\n\nstreamplot(bd, \"bx;bz\")\nstreamplot(bd, \"bx;bz\"; density=2.0, color=\"k\", plotinterval=1.0, plotrange=[-10,10,-Inf,Inf])\n\nquiver (currently only for Cartesian grid)\n\nquiver(bd, \"ux;uy\"; stride=50)\n\nstreamline + contourf\n\nfile = \"y.out\"\nbd = load(file)\n\nDN = matplotlib.colors.DivergingNorm\ncmap = matplotlib.cm.RdBu_r\n\ncontourf(bd, \"uxS0\", 50; plotrange=[-3,3,-3,3], plotinterval=0.05, norm=DN(0), cmap)\ncolorbar()\nstreamplot(bd, \"uxS0;uzS0\"; density=2.0, color=\"g\", plotrange=[-3,3,-3,3])\nxlabel(\"x\"); ylabel(\"y\"); title(\"Ux [km/s]\")\n\ncontourf(bd, \"uxS0\", 50; plotinterval=0.05, norm=DN(0), cmap)\ncolorbar()\naxis(\"scaled\")\nxlabel(\"x\"); ylabel(\"y\"); title(\"uxS0\")\n\nFor 3D outputs, we may use cutplot for visualizing on a sliced plane, or streamslice to plot streamlines on a given slice.","category":"section"},{"location":"man/manual/#Finding-indexes","page":"Manual","title":"Finding indexes","text":"To get the index of a certain quantity, e.g. electron number density\n\nρe_= findfirst(x->x==\"rhos0\", bd.head.wname)","category":"section"},{"location":"man/manual/#Get-variable-range","page":"Manual","title":"Get variable range","text":"wmin, wmax = get_var_range(bd, var)","category":"section"},{"location":"man/manual/#Tracing","page":"Manual","title":"Tracing","text":"The built-in streamplot function in Matplotlib is not satisfactory for accurately tracing. Instead we recommend FieldTracer.jl for tracing fieldlines and streamlines.\n\nAn example of tracing in a 2D cut and plot the field lines over contour:\n\nfile = \"test/y=0_var_1_t00000000_n00000000.out\"\nbd = load(file)\n\nbx = bd.w[:,:,5]\nbz = bd.w[:,:,7]\nx  = bd.x[:,1,1]\nz  = bd.x[1,:,2]\n\nseeds = select_seeds(x, z; nSeed=100) # randomly select the seeding points\n\nfor i in 1:size(seeds)[2]\n   xs = seeds[1,i]\n   zs = seeds[2,i]\n   # Tracing in both direction. Check the document for more options.\n   x1, z1 = trace2d_eul(bx, bz, xs, zs, x, z, ds=0.1, maxstep=1000, gridType=\"ndgrid\")\n   plot(x1, z1, \"--\")\nend\naxis(\"equal\")\n\nCurrently the select_seeds function uses pseudo random number generator that produces the same seeds every time.","category":"section"},{"location":"man/manual/#AMReX-Particle-Data","page":"Manual","title":"AMReX Particle Data","text":"We provide support for reading and analyzing AMReX particle data.","category":"section"},{"location":"man/manual/#Loading-Data","page":"Manual","title":"Loading Data","text":"To load AMReX particle data:\n\ndata = AMReXParticle(\"path/to/data_directory\")\n\nThis will parse the header and prepare for lazy loading of particle data.","category":"section"},{"location":"man/manual/#Phase-Space-Plotting","page":"Manual","title":"Phase Space Plotting","text":"We can calculate and plot the phase space density distribution of particles.\n\nFirst, load the PyPlot extension. The plot_phase function automatically calculates the density and plots it.\n\nusing PyPlot\n\nplot_phase(data, \"x\", \"vx\"; \n   bins=100, \n   x_range=(-10, 10), \n   y_range=(-5, 5),\n   log_scale=true,\n   plot_zero_lines=true,\n   normalize=true\n)\n\nWe can also calculate the phase space density histogram directly without plotting:\n\n# 1D density\nhist1d = get_phase_space_density(data, \"vx\")\n\n# 2D density\nhist2d = get_phase_space_density(data, \"x\", \"vx\"; bins=(100, 50))\n\n# 3D density\nhist3d = get_phase_space_density(data, \"vx\", \"vy\", \"vz\"; bins=50)\n\n# Weighted 2D density (automatically detects \"weight\" component if present)\n# or passes weights explicitly if not in data\nhist2d_w = get_phase_space_density(data, \"v_parallel\", \"v_perp\")\n\nWe can also apply coordinate transformations to the particle data.\n\nTransformation with only B field. This decomposes velocity into parallel and perpendicular components relative to B.\n\ntransform_b = get_particle_field_aligned_transform([1.0, 0.0, 0.0])\n\nplot_phase(data, \"v_parallel\", \"v_perp\"; \n   transform=transform_b,\n   bins=50,\n   log_scale=true\n)\n\nTransformation with both B and E fields. This creates an orthonormal basis (v_B, v_E, v_B times E), where v_B is along B, v_E is along the perpendicular component of E, and v_B times E is along the ExB drift direction.\n\ntransform_eb = get_particle_field_aligned_transform([1.0, 0.0, 0.0], [0.0, 1.0, 0.0])\n\nplot_phase(data, \"v_B\", \"v_BxE\"; \n   transform=transform_eb,\n   bins=50,\n   log_scale=true\n)","category":"section"},{"location":"man/manual/#Particle-Classification","page":"Manual","title":"Particle Classification","text":"You can classify particles into Core Maxwellian and Suprathermal populations using classify_particles. This function allows for specifying a spatial region and handling velocity distributions in 1D, 2D, or 3D.\n\n# range can be specified by keywords x_range, y_range, z_range locally\ncore, halo = classify_particles(data; \n    x_range=(-1.0, 1.0), \n    y_range=(-1.0, 1.0), \n    z_range=(-1.0, 1.0),\n    vdim=3,          # Velocity dimension (1, 2, or 3)\n    vth=1.0,         # Core thermal velocity (required)\n    nsigma=3.0,      # Separation threshold\n    bulk_vel=nothing # Auto-detect if nothing\n)\n\nThe function returns two matrices containing the classified particles. If bulk_vel is not provided, it is automatically estimated from the peak of the velocity distribution.","category":"section"},{"location":"examples/visualization/demo_animate_2d/#demo_contour_animation","page":"Contour Animation","title":"Contour Animation","text":"(Image: Author) (Image: Update time)\n\nThis example shows how to create 2D colored contour animation from series of SWMF outputs using Matplotlib.\n\nTime-dependent title.\nTweakable colorbar.\nPlotting streamline on top of colored contours is a bit hacky because there is currently no intrinsic methods for removing the streamlines. Our solution here is to dispatch a streamline into lines and arrows and then remove them separately.\n\nusing Batsrus, PyPlot, Printf, PyCall\n\nconst fontsize = 14\n\n\"\"\"\n    animate(files::Vector{String}; kwargs...)\n\nGenerate figures of colored contour, optionally with streamlines.\n\n# Keywords\n- `var`: variable to plot with pcolormesh.\n- `vmin`: minimum plotting value.\n- `vmax`: maximum plotting value.\n- `plotrange`: 2D plotting spatial range.\n- `plotinterval`: spatial sampling interval.\n- `cmap`: colormap accepted by Matplotlib.\n- `streamvars`: if set, add streamlines to the colored contour.\n- `density`: streamline density.\n- `orientation`: colorbar orientation, \"horizontal\" or \"vertical\".\n- `extend`: colorbar extension, \"neither\", \"both\", \"min\", \"max\".\n- `use_conventional_notation`: if true, denote the vertical axis as \"z\".\n- `broken_streamlines`: if true, streamlines can be broken.\n- `overwrite`: if true, overwrite the existing image files.\n- `filedir`: source data directory.\n- `outdir`: output image directory.\n\"\"\"\nfunction animate(files::Vector{String}; var=\"Uy\", vmin=-Inf, vmax=Inf,\n   plotrange=[-Inf, Inf, -Inf, Inf], plotinterval=Inf,\n   cmap=matplotlib.cm.RdBu_r, streamvars=nothing, density=1, orientation=\"horizontal\",\n   extend=\"neither\", use_conventional_notation=false, broken_streamlines=false,\n   overwrite=false, filedir=\"./\", outdir=\"out/\")\n\n   bd = load(filedir*files[1])\n\n   nfile = length(files)\n   if isnan(vmin+vmax)\n      vmin = isinf(vmin) ? minimum(v) : vmin\n      vmax = isinf(vmax) ? maximum(v) : vmax\n   end\n\n   norm = matplotlib.colors.Normalize(vmin, vmax)\n\n   filetype =\n      if occursin(\"region\", files[1])\n         :PC\n      else\n         :GM\n      end\n\n   if use_conventional_notation # switch y and z axis\n      if var[2] == 'y'\n         cb_str = \n            if startswith(var, \"U\")\n               \"Uz [km/s]\"\n            elseif startswith(var, \"B\")\n               \"Bz [nT]\"\n            elseif startswith(var, \"E\")\n               L\"Ez [$\\mu\\mathrm{V}/\\mathrm{m}$]\"\n            else\n               var\n            end\n      elseif var[2] == 'z'\n         cb_str = \n            if startswith(var, \"U\")\n               \"Uy [km/s]\"\n            elseif startswith(var, \"B\")\n               \"By [nT]\"\n            elseif startswith(var, \"E\")\n               L\"Ey [$\\mu\\mathrm{V}/\\mathrm{m}$]\"\n            else\n               var\n            end\n      end\n   else\n      cb_str = \n         if startswith(var, \"U\")\n            var * \" [km/s]\"\n         elseif startswith(var, \"B\")\n             var * \" [nT]\"\n         elseif startswith(var, \"E\")\n            var * L\" [\\mu\\mathrm{V}/\\mathrm{m}]\"\n         else\n            var\n         end\n   end\n\n   fig = plt.figure(figsize=(4, 8), constrained_layout=true)\n   ax = plt.axes()\n   ax.set_xlabel(L\"x [$\\mathrm{R}_\\mathrm{E}$]\"; fontsize)\n   ax.set_ylabel(L\"y [$\\mathrm{R}_\\mathrm{E}$]\"; fontsize)\n\n   @info \"1 out of $nfile\"\n   x, y, w = Batsrus.getdata2d(bd, var, plotrange, plotinterval; innermask=false)\n   c = ax.pcolormesh(x, y, w; norm, cmap)\n   ax.set_aspect(\"equal\", adjustable=\"box\", anchor=\"C\")\n\n   if orientation == \"horizontal\"\n      cb = colorbar(c; ax, orientation, location=\"top\", aspect=50, extend)\n   else\n      cb = colorbar(c; ax, orientation, extend)  \n   end\n   cb.ax.set_ylabel(cb_str; fontsize)\n   #cb.ax.set_title(cb_str; fontsize)\n   title_str = @sprintf \"t = %4.1f s\" bd.head.time\n   ax.set_title(title_str)\n\n   if bd.head.gencoord\n      if !isnothing(streamvars)\n         xi, yi, v1, v2 = get_vector(bd, streamvars, plotrange, plotinterval)\n         st = ax.streamplot(xi, yi, v1, v2; color=\"gray\", density)\n      end\n   else\n      if !isnothing(streamvars)\n         st = streamplot(bd, streamvars, ax; color=\"gray\", density, broken_streamlines)\n      end\n   end\n\n   savefig(outdir*lpad(1, 4, '0')*\".png\", bbox_inches=\"tight\", dpi=200)\n\n   if !isnothing(streamvars) # Clean up streamlines\n      st.lines.remove()\n      for art in ax.get_children()\n         if !pybuiltin(:isinstance)(art, matplotlib.patches.FancyArrowPatch)\n            continue\n         end\n         art.remove()\n      end\n   end\n\n   for i in 2:nfile\n      @info \"$i out of $nfile\"\n      outname = outdir*lpad(i, 4, '0')*\".png\"\n      if !overwrite\n         isfile(outname) && continue\n      end\n      bd = load(joinpath(filedir, files[i]))\n      if bd.head.gencoord\n         _, _, wi = getdata2d(bd, var, plotrange, plotinterval; innermask=false)\n      else\n         wi = bd[var]'\n      end\n\n      c.set_array(wi)\n\n      if !isnothing(streamvars)\n         if bd.head.gencoord\n            xi, yi, v1, v2 = get_vector(bd, streamvars, plotrange, plotinterval)\n            st = ax.streamplot(xi, yi, v1, v2; color=\"gray\", density)\n         else\n            st = streamplot(bd, \"Bx;By\", ax; color=\"gray\", density, broken_streamlines)\n         end\n      end\n\n      title_str = @sprintf \"t = %4.1f s\" bd.head.time\n      ax.set_title(title_str)\n   \n      savefig(outname, bbox_inches=\"tight\", dpi=200)\n      if !isnothing(streamvars) # Clean up streamlines\n         st.lines.remove()\n         for art in ax.get_children()\n            if !pybuiltin(:isinstance)(art, matplotlib.patches.FancyArrowPatch)\n               continue\n            end\n            art.remove()\n         end\n      end\n   end\n   \n   close()\nend\n\nfunction get_vector(bd, var, plotrange, plotinterval)\n   x, w = bd.x, bd.w\n   X, Y = eachslice(x, dims=3)\n   X, Y = vec(X), vec(Y)\n   varstream = split(var, \";\")\n   var1_ = findfirst(x->lowercase(x)==lowercase(varstream[1]), bd.head.wname)\n   var2_ = findfirst(x->lowercase(x)==lowercase(varstream[2]), bd.head.wname)\n   # Create grid values first.\n   xi = range(Float64(plotrange[1]), stop=Float64(plotrange[2]), step=plotinterval)\n   yi = range(Float64(plotrange[3]), stop=Float64(plotrange[4]), step=plotinterval)\n\n   tr = matplotlib.tri.Triangulation(X, Y)\n   Xi, Yi = Batsrus.meshgrid(xi, yi)\n\n   W1 = @views w[:,:,var1_] |> vec\n   interpolator = matplotlib.tri.LinearTriInterpolator(tr, W1)\n   v1 = interpolator(Xi, Yi)\n\n   W2 = @views w[:,:,var2_] |> vec\n   interpolator = matplotlib.tri.LinearTriInterpolator(tr, W2)\n   v2 = interpolator(Xi, Yi)\n\n   xi, yi, v1, v2\nend\n\n#######################\nfiledir = \"GM/\"\n\nfiles = filter(file -> startswith(file, \"z\") && endswith(file, \".out\"), readdir(filedir))\n\nvar = \"Bz\"\nvmin = -10\nvmax = 10\ncmap = matplotlib.cm.RdBu_r\nstreamvars = \"Bx;By\"\ndensity = 1\norientation = \"vertical\"\noutdir = \"out/\"\nextend = \"both\"\nuse_conventional_notation = true\n\nanimate(files; filedir, outdir, var, vmin, vmax, orientation, cmap, streamvars, density,\n   extend, use_conventional_notation)\n\n\n\nThis page was generated using DemoCards.jl.","category":"section"},{"location":"examples/utility/demo_satellite_2d/#demo_satellite_2d","page":"Virtual Satellite Extraction","title":"Virtual Satellite Extraction","text":"(Image: Author) (Image: Update time)\n\nThis example shows how to extract virtual satellite data from FLEKS output as a time series.\n\nusing Batsrus, JLD2\n\nfunction save_static_satellite_data(\n   loc;\n   filedir = \"./\",\n   outname = \"satellite.jld2\",\n   tstep = 1.0,\n)\n   pick_file = file -> startswith(file, \"z\") && endswith(file, \".out\")\n\n   files = [joinpath(filedir, f) for f in readdir(filedir) if pick_file(f)]\n\n   trange, v = get_timeseries(files, loc; tstep)\n   jldsave(outname; trange, v, loc)\nend\n\n#####\nmi2me = 16\nf = 2\ndeg = 0\ndim = 3\ndx = 1 # [de]\ntstep = 1.0 # output time cadence\n# Data directory\ntopdir = \"/home1/\"\nfiledir = joinpath(topdir, \"RESULT/run1/PC/\")\noutdir = joinpath(topdir, \"run1/\")\n\nif !isdir(outdir)\n   println(\"Creating figure saving directory:\")\n   println(outdir)\n   mkdir(outdir)\nelse\n   println(\"Output data saving directory:\")\n   println(outdir)\nend\n\nlocs = [Float32[i, 0] for i in range(10, 20, step=5)]\n\nfor i in eachindex(locs)\n   @info \"Location $(i)\"\n   loc = locs[i]\n   outname = joinpath(outdir, \"satellite_$(dim)d$(deg)deg_mi2me$(mi2me)_f$(f)_$i.jld2\")\n   isfile(outname) && continue\n   save_static_satellite_data(loc; filedir, outname, tstep)\nend\n\n\n\nThis page was generated using DemoCards.jl.","category":"section"},{"location":"examples/visualization/demo_animate_1d_lines/#demo_lines_animation","page":"Subplot Line Animation","title":"Subplot Line Animation","text":"(Image: Author) (Image: Update time)\n\nThis example shows how to create multi-panel 1D space line animation from a series of FLEKS outputs.\n\nTwin axes sharing the same x-axis for showing two quantities in one frame.\nTime-dependent title.\nFixed value ranges.\n\nSince currently we don't have true 1D outputs, in this demo we show the way to extract the first column from 2D cuts.\n\nusing Batsrus, Printf, PyPlot\n\nfunction create_figure()\n   fig, axs = subplots(5, 1, figsize=(12, 8),\n      sharex=true, sharey=false, constrained_layout=true)\n\n   lw1 = 1.0\n   lw2 = 1.0\n   lw3 = 1.0\n\n   xmin, xmax = -6300.0, -1300.0\n\n   ρemin, ρemax = 0.0, 0.05 # mi/me = 400\n   ρimin, ρimax = 0.0, 20.0\n   vmin, vmax = -600.0, 300.0\n   pmin, pmax = 1e-3, 1.0\n   Bmin, Bmax = -3.0, 30.0\n   Emin, Emax = -5.0, 5.0\n\n   l11, = axs[1].plot([], [], lw=lw1)\n   l211, = axs[2].plot([], [], lw=lw1, label=\"Uex\")\n   l212, = axs[2].plot([], [], lw=lw1, label=\"Uey\")\n   l213, = axs[2].plot([], [], lw=lw1, label=\"Uez\")\n   l311, = axs[3].plot([0.0, 1.0], [pmin, pmax], lw=lw1, alpha=0.8, label=L\"$P_{exx}$\")\n   l312, = axs[3].plot([0.0, 1.0], [pmin, pmax], lw=lw1, alpha=0.8, label=L\"$P_{eyy}$\")\n   l313, = axs[3].plot([0.0, 1.0], [pmin, pmax], lw=lw1, alpha=0.8, label=L\"$P_{ezz}$\")\n   l41, = axs[4].plot([], [], lw=lw2, label=\"x\")\n   l42, = axs[4].plot([], [], lw=lw2, label=\"y\")\n   l43, = axs[4].plot([], [], lw=lw2, label=\"z\")\n   l51, = axs[5].plot([], [], lw=lw2, label=\"x\")\n   l52, = axs[5].plot([], [], lw=lw2, label=\"y\")\n   l53, = axs[5].plot([], [], lw=lw2, label=\"z\")\n\n   axs[1].set_xlim(xmin, xmax)\n   axs[1].set_ylim(ρemin, ρemax)\n   axs[2].set_ylim(vmin, vmax)\n   axs[3].set_yscale(\"log\")\n   axs[3].set_ylim(pmin, pmax)\n   axs[4].set_ylim(Bmin, Bmax) # B\n   axs[5].set_ylim(Emin, Emax) # E\n\n   for ax in axs\n      ax.grid(true)\n   end\n\n   axs[4].set_ylabel(\"B [nT]\"; fontsize)\n   axs[5].set_ylabel(\"E [mV/m]\"; fontsize)\n\n   axs[end].set_xlabel(\"x [km]\"; fontsize)\n\n   axs[1].set_ylabel(L\"$\\rho_e$ [amu/cc]\"; fontsize, color=\"tab:blue\")\n   axs[1].tick_params(axis=\"y\", labelcolor=\"tab:blue\")\n\n   ax12 = axs[1].twinx()\n   ax12.set_ylim(ρimin, ρimax)\n\n   ax12.set_ylabel(L\"$\\rho_i$ [amu/cc]\"; fontsize, color=\"tab:red\")\n\n   l12, = ax12.plot([], []; lw=lw1, color=\"tab:red\", alpha=0.8)\n   ax12.tick_params(axis=\"y\", labelcolor=\"tab:red\")\n\n   axs[2].set_ylabel(L\"$U_e$ [km/s]\"; fontsize)\n\n   ax22 = axs[2].twinx()\n   ax22.set_ylim(vmin, vmax)\n\n   ax22.set_ylabel(L\"$U_i$ [km/s]\"; fontsize)\n\n   l221, = ax22.plot([], [], lw=lw3, label=\"Uix\", color=\"tab:red\")\n   l222, = ax22.plot([], [], lw=lw3, label=\"Uiy\", color=\"tab:purple\")\n   l223, = ax22.plot([], [], lw=lw3, label=\"Uiz\", color=\"tab:brown\")\n\n   axs[3].set_ylabel(L\"$P_e$ [nT]\"; fontsize)\n\n   ax32 = axs[3].twinx()\n   ax32.set_ylabel(L\"$P_i$ [nT]\"; fontsize)\n\n   fake_range = [0.0, 1.0]\n   p_range = [pmin, pmax]\n   p_alpha = 0.8\n   l321, = ax32.plot(fake_range, p_range, lw=lw3, alpha=p_alpha, label=L\"$P_{ixx}$\",\n      color=\"tab:red\")\n   l322, = ax32.plot(fake_range, p_range, lw=lw3, alpha=p_alpha, label=L\"$P_{iyy}$\",\n      color=\"tab:purple\")\n   l323, = ax32.plot(fake_range, p_range, lw=lw3, alpha=p_alpha, label=L\"$P_{izz}$\",\n      color=\"tab:brown\")\n\n   ax32.set_yscale(\"log\")\n   ax32.set_ylim(p_range...)\n\n   leg21 = axs[2].legend(;loc=(0.34, 0.05), ncols=3, frameon=false)\n   leg22 = ax22.legend(;loc=(0.0, 0.05), ncols=3, frameon=false)\n   leg31 = axs[3].legend(;loc=(0.34, -0.05), ncols=3, frameon=false)\n   leg32 = ax32.legend(;loc=(0.0, -0.05), ncols=3, frameon=false)\n   leg4 = axs[4].legend(;loc=\"upper left\", ncols=3, frameon=false)\n   leg5 = axs[5].legend(;loc=\"upper left\", ncols=3, frameon=false)\n\n   # set the linewidth of each legend object\n   legs = (leg21, leg22, leg31, leg32, leg4, leg5)\n   for leg in legs\n      for legobj in leg.legend_handles\n         legobj.set_linewidth(1.5)\n      end\n   end\n\n   ls = (l11, l12, l211, l212, l213, l221, l222, l223, l311, l312, l313, l321, l322, l323,\n      l41, l42, l43, l51, l52, l53)\n\n   axs, ls\nend\n\nfunction slice1d_avg(bd, var, dir::Int=2)\n   mean(bd[var], dims=dir) |> vec\nend\n\nfunction animate(files::Vector{String}, axs, ls; outdir=\"out/\", overwrite::Bool=false,\n   icut::Int=1, nbox::Int=1, dir=2, doAverage::Bool=false)\n   l11, l12, l211, l212, l213, l221, l222, l223, l311, l312, l313, l321, l322, l323,\n      l41, l42, l43, l51, l52, l53 = ls\n\n   for (i, file) in enumerate(files)\n      @info \"$i in $(length(files))\"\n      outname = outdir*lpad(i, 4, '0')*\".png\"\n      if !overwrite\n         isfile(outname) && continue\n      end\n\n      bd = load(joinpath(filedir, file))\n\n      x = @views bd.x[:,1,1]\n\n      if doAverage\n         slice = let bd = bd, dir = dir, nbox = nbox\n            var -> moving_average(slice1d_avg(bd, var, dir), nbox)\n         end\n      else\n         slice = let bd = bd, dir = dir, nbox = nbox, icut = icut\n            var -> moving_average(slice1d(bd, var, icut, dir), nbox)\n         end\n      end\n\n      d = slice(\"rhos0\")\n      l11.set_data(x, d)\n      d = slice(\"rhos1\")\n      l12.set_data(x, d)\n      d = slice(\"Uxs0\")\n      l211.set_data(x, d)\n      d = slice(\"Uys0\")\n      l212.set_data(x, d)\n      d = slice(\"Uzs0\")\n      l213.set_data(x, d)\n      d = slice(\"Uxs1\")\n      l221.set_data(x, d)\n      d = slice(\"Uys1\")\n      l222.set_data(x, d)\n      d = slice(\"Uzs1\")\n      l223.set_data(x, d)\n      d = slice(\"PXXS0\")\n      l311.set_data(x, d)\n      d = slice(\"PYYS0\")\n      l312.set_data(x, d)\n      d = slice(\"PZZS0\")\n      l313.set_data(x, d)\n      d = slice(\"PXXS1\")\n      l321.set_data(x, d)\n      d = slice(\"PYYS1\")\n      l322.set_data(x, d)\n      d = slice(\"PZZS1\")\n      l323.set_data(x, d)\n\n      d = slice_data(\"Bx\")\n      l41.set_data(x, d)\n      d = slice_data(\"By\")\n      l42.set_data(x, d)\n      d = slice_data(\"Bz\")\n      l43.set_data(x, d)\n      d = slice_data(\"Ex\") ./ 1000\n      l51.set_data(x, d)\n      d = slice_data(\"Ey\") ./ 1000\n      l52.set_data(x, d)\n      d = slice_data(\"Ez\") ./ 1000\n      l53.set_data(x, d)\n\n      title_str = @sprintf \"t = %4.1f s\" bd.head.time\n      axs[1].set_title(title_str; fontsize)\n\n      savefig(outname, bbox_inches=\"tight\", dpi=200)\n   end\n\n   return\nend\n\n#################\n\n# Data directory\nfiledir = \"./\"\n\nconst fontsize = 16\n\npick_file = file -> startswith(file, \"z\") && endswith(file, \".out\")\n\nfiles = filter(pick_file, readdir(filedir))\n\naxs, ls = create_figure()\nanimate(files, axs, ls; icol=1, outdir=\"figures/\", overwrite=true)\n\nclose()\n\n\n\nThis page was generated using DemoCards.jl.","category":"section"},{"location":"examples/#examples","page":"Examples","title":"Examples","text":"This section contains thorough examples of using Batsrus.jl.\n\n","category":"section"},{"location":"examples/#Utility","page":"Examples","title":"Utility","text":"<div class=\"list-card-section\">\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nVirtual Satellite Extraction\n\n</div>\n    <div class=\"list-card-description\">\n\nSatellite extraction from 2D slices\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n</div>","category":"section"},{"location":"examples/#Visualization","page":"Examples","title":"Visualization","text":"<div class=\"list-card-section\">\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nLine Animation\n\n</div>\n    <div class=\"list-card-description\">\n\n1D line animation using pyplot\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nSubplot Line Animation\n\n</div>\n    <div class=\"list-card-description\">\n\nSubplot 1D line animation using pyplot\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n<div class=\"list-card\">\n<table>\n  <td><div class=\"list-card-text\">\n\nContour Animation\n\n</div>\n    <div class=\"list-card-description\">\n\n2D contour animation using pyplot\n\n    </div>\n  </td>\n</tbody></table>\n</div>\n\n</div>\n\n","category":"section"},{"location":"man/internal/#APIs","page":"Internal","title":"APIs","text":"","category":"section"},{"location":"man/internal/#Batsrus","page":"Internal","title":"Batsrus","text":"","category":"section"},{"location":"man/internal/#UnitfulBatsrus","page":"Internal","title":"UnitfulBatsrus","text":"","category":"section"},{"location":"man/internal/#HDF","page":"Internal","title":"HDF","text":"","category":"section"},{"location":"man/internal/#Batsrus.BATS","page":"Internal","title":"Batsrus.BATS","text":"Alias for backward compatibility and convenience.\n\n\n\n\n\n","category":"type"},{"location":"man/internal/#Batsrus.Batl","page":"Internal","title":"Batsrus.Batl","text":"BATSRUS output high-level struct.\n\n\n\n\n\n","category":"type"},{"location":"man/internal/#Batsrus.BatsHead","page":"Internal","title":"Batsrus.BatsHead","text":"Batsrus file head information.\n\n\n\n\n\n","category":"type"},{"location":"man/internal/#Batsrus.BatsrusIDLStructured","page":"Internal","title":"Batsrus.BatsrusIDLStructured","text":"Batsrus structured data container, with Dim being the dimension of output.\n\n\n\n\n\n","category":"type"},{"location":"man/internal/#Batsrus.BatsrusIDLUnstructured","page":"Internal","title":"Batsrus.BatsrusIDLUnstructured","text":"Batsrus unstructured data container, with Dim being the dimension of output.\n\n\n\n\n\n","category":"type"},{"location":"man/internal/#Batsrus.FileList","page":"Internal","title":"Batsrus.FileList","text":"Type for Batsrus file information.\n\n\n\n\n\n","category":"type"},{"location":"man/internal/#Batsrus.Head","page":"Internal","title":"Batsrus.Head","text":"BATSRUS output standalone header information.\n\n\n\n\n\n","category":"type"},{"location":"man/internal/#Batsrus._getfilesize_binary-Union{Tuple{T}, Tuple{IOStream, Integer, Val{T}}} where T","page":"Internal","title":"Batsrus._getfilesize_binary","text":" getfilesize(fileID::IOStream, lenstr::Int32, ::Val{FileType})\n\nReturn the size in bytes for one snapshot.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.adjust_plotrange!-Tuple{Any, Any, Any}","page":"Internal","title":"Batsrus.adjust_plotrange!","text":"Adjust 2D plot ranges.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.allocateBuffer-Union{Tuple{T}, Tuple{Batsrus.BatsHead, Type{T}}} where T","page":"Internal","title":"Batsrus.allocateBuffer","text":"Create buffer for x and w.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.classify_particles-Union{Tuple{AMReXParticle{T}}, Tuple{T}} where T","page":"Internal","title":"Batsrus.classify_particles","text":"classify_particles(data, region; vdim=3, bulk_vel=nothing, vth=nothing, nsigma=3.0)\n\nClassify particles in a spatial region into core Maxwellian and suprathermal populations.\n\nArguments\n\ndata::AMReXParticle: Particle data.\nregion: Passed as kwargs x_range, y_range, z_range.\nvdim: Velocity dimension (1, 2, or 3).\nbulk_vel: Core bulk velocity. If nothing, estimated from peak density.\nvth: Core thermal velocity. Must be provided.\nnsigma: Threshold for classification in units of thermal velocity.\n\nReturns\n\n(core, suprathermal): Two matrices containing the classified particles.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.convertIDLtoVTK-Tuple{AbstractString}","page":"Internal","title":"Batsrus.convertIDLtoVTK","text":" convertIDLtoVTK(filename; gridType=1, verbose=false)\n\nConvert 3D BATSRUS *.out to VTK. If filename does not end with \"out\", it tries to find the \".info\" and \".tree\" file with the same name tag and generates 3D unstructured VTU file.\n\nKeywords\n\ngridType::Symbol: Type of target VTK grid (vti: image, vtr: rectilinear, vts: structured grid).\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.convertTECtoVTU","page":"Internal","title":"Batsrus.convertTECtoVTU","text":" convertTECtoVTU(file::AbstractString, outname=\"out\")\n convertTECtoVTU(head, data, connectivity, outname=\"out\")\n\nConvert unstructured Tecplot data to VTK. Note that if using voxel type data in VTK, the connectivity sequence is different from Tecplot: the 3D connectivity sequence in Tecplot is the same as the hexahedron type in VTK, but different with the voxel type. The 2D connectivity sequence is the same as the quad type, but different with the pixel type. For example, in 3D the index conversion is:\n\n# PLT to VTK voxel index_ = [1 2 4 3 5 6 8 7]\nfor i in 1:2\n\tconnectivity = swaprows!(connectivity, 4*i-1, 4*i)\nend\n\n\n\n\n\n","category":"function"},{"location":"man/internal/#Batsrus.create_pvd-Tuple{String}","page":"Internal","title":"Batsrus.create_pvd","text":" create_pvd(filepattern)\n\nGenerate PVD file for a time series collection of VTK data.\n\nExample\n\ncreate_pvd(\"*.vtu)\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.cutdata-Tuple{BatsrusIDL, AbstractString}","page":"Internal","title":"Batsrus.cutdata","text":"cutdata(data, var; plotrange=[-Inf,Inf,-Inf,Inf], dir=\"x\", sequence=1)\n\nGet 2D plane cut in orientation dir for var out of 3D box data within plotrange. The returned 2D data lies in the sequence plane from - to + in dir.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.fillCellNeighbors!-Tuple{Batl, Vararg{Any, 4}}","page":"Internal","title":"Batsrus.fillCellNeighbors!","text":" fillCellNeighbors!(batl, iCell_G, DiLevelNei_III, iNodeNei_III, nBlock_P)\n\nFill neighbor cell indexes for the given block. The faces, edges, and vertices are ordered from left (-) to right (+) in x-y-z sequentially.\n\nVertices:        Edges: (10,11 ignored)\n\n7 ----- 8        . --4-- .\n\n.     - .      7 .     8 . 5 ––- 6  .     . –3– .  12 .  .    .  .     .  .    .  . .  3 ––- 4     9  . –2– . . -     . -      . 5     . 6 1 ––- 2        . –1– .\n\nOnly tested for 3D.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.fill_vector_from_scalars-Tuple{BatsrusIDL, Any}","page":"Internal","title":"Batsrus.fill_vector_from_scalars","text":" fill_vector_from_scalars(bd::BatsrusIDL, var)\n\nConstruct vector of var from its scalar components. Alternatively, check get_vectors for returning vector components as separate arrays.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.find_grid_block-Tuple{Batl, Any}","page":"Internal","title":"Batsrus.find_grid_block","text":" find_grid_block(batl, xyz_D)\n\nReturn processor local block index that contains a point. Input location should be given in Cartesian coordinates.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.find_neighbor_for_anynode-Tuple{Batl, Int64}","page":"Internal","title":"Batsrus.find_neighbor_for_anynode","text":"Find neighbors for any node in the tree. Only for Cartesian now.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.find_tree_node-Tuple{Batl, Any}","page":"Internal","title":"Batsrus.find_tree_node","text":" find_tree_node(batl, Coord_D)\n\nFind the node that contains a point. The point coordinates should be given in generalized coordinates normalized by the domain size.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.findindex-Tuple{BatsrusIDL, AbstractString}","page":"Internal","title":"Batsrus.findindex","text":"Find variable index in the BATSRUS data.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.fit_particle_velocity_gmm-Union{Tuple{T}, Tuple{AMReXParticle{T}, Int64}} where T","page":"Internal","title":"Batsrus.fit_particle_velocity_gmm","text":"fit_particle_velocity_gmm(data, n_clusters; x_range=nothing, y_range=nothing, z_range=nothing, vdim=3)\n\nFit a Gaussian Mixture Model to particle velocities in a region.\n\nArguments\n\ndata: AMReXParticle data.\nn_clusters: Number of GMM components.\nvdim: Velocity dimension (1, 2, or 3).\nkind: Covariance kind, :full (default) or :diag.\n\nReturns\n\nA vector of named tuples sorted by weight, each containing:\nweight: Component weight.\nmean: Component mean velocity (vector of length vdim).\ncov: Component covariance matrix (vdim x vdim).\nvth: Component thermal velocity (diagonal approximation).\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.fit_particle_velocity_gmm-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Int64}} where T","page":"Internal","title":"Batsrus.fit_particle_velocity_gmm","text":"fit_particle_velocity_gmm(velocities::AbstractMatrix, n_clusters::Int; weights=nothing, kind=:full)\n\nFit a Gaussian Mixture Model to particle velocities.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.generate_mock_amrex_data-Tuple{String}","page":"Internal","title":"Batsrus.generate_mock_amrex_data","text":" generate_mock_amrex_data(output_dir::String; num_particles::Int=10, \n    real_component_names::Vector{String}=[\"u\", \"v\"],\n    particle_gen::Function)\n\nGenerate mock AMReX particle data for testing and benchmarking.\n\nArguments\n\noutput_dir::String: Directory to save the mock data.\nnum_particles::Int: Number of particles to generate.\nreal_component_names::Vector{String}: Names of the extra real components (beyond x, y, z).\nparticle_gen::Function: A function (i, n_reals) -> tuple that takes an index i (1-based) and the total number of real components n_reals. It should return a tuple of n_reals Float64 values: (x, y, z, comp1, comp2, ...).\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.getConnectivity-Tuple{Batl}","page":"Internal","title":"Batsrus.getConnectivity","text":"Get cell connectivity list.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.getRotationMatrix-Tuple{AbstractVector{<:AbstractFloat}, Real}","page":"Internal","title":"Batsrus.getRotationMatrix","text":" getRotationMatrix(axis::AbstractVector, angle::Real) --> SMatrix{3,3}\n\nCreate a rotation matrix for rotating a 3D vector around a unit axis by an angle in radians. Reference: Rotation matrix from axis and angle\n\nExample\n\nusing LinearAlgebra\nv = [-0.5, 1.0, 1.0]\nv̂ = normalize(v)\nθ = deg2rad(-74)\nR = getRotationMatrix(v̂, θ)\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.getSibling-Tuple{Any, Any}","page":"Internal","title":"Batsrus.getSibling","text":"Return sibling index (1-8) for the given block node matrix.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.get_anisotropy-Union{Tuple{BatsrusIDL{2, TV}}, Tuple{TV}, Tuple{BatsrusIDL{2, TV}, Any}} where TV","page":"Internal","title":"Batsrus.get_anisotropy","text":" get_anisotropy(bd::BatsrusIDL, species=0)\n\nCalculate the pressure anisotropy for species, indexing from 0. The default method is based on the fact that the trace of the pressure tensor is a constant. The rotation method is based on rotating the tensor.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.get_convection_E-Tuple{BatsrusIDL}","page":"Internal","title":"Batsrus.get_convection_E","text":"Return the convection electric field from PIC outputs.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.get_core_population_mask-Union{Tuple{T}, Tuple{AbstractMatrix{T}, AbstractVector, Union{Real, AbstractVector}}, Tuple{AbstractMatrix{T}, AbstractVector, Union{Real, AbstractVector}, Real}} where T","page":"Internal","title":"Batsrus.get_core_population_mask","text":"get_core_population_mask(velocities, bulk_vel, vth, nsigma=3.0)\n\nIdentify core population particles based on velocity distribution. Returns a BitVector where true indicates a core particle.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.get_gmm_thermal_velocity-Union{Tuple{T}, Tuple{Any, AbstractVector{T}}} where T","page":"Internal","title":"Batsrus.get_gmm_thermal_velocity","text":"get_gmm_thermal_velocity(gmm_component, b_field)\n\nCalculate parallel and perpendicular thermal velocities from a GMM component.\n\nReturns\n\n(v_th_para, v_th_perp)\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.get_hall_E-Tuple{BatsrusIDL}","page":"Internal","title":"Batsrus.get_hall_E","text":"Return the Hall electric field from PIC outputs.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.get_magnitude","page":"Internal","title":"Batsrus.get_magnitude","text":" get_magnitude(bd::BatsrusIDL, var)\n\nCalculate the magnitude of vector var. See get_vectors for the options.\n\n\n\n\n\n","category":"function"},{"location":"man/internal/#Batsrus.get_magnitude2","page":"Internal","title":"Batsrus.get_magnitude2","text":" get_magnitude2(bd::BatsrusIDL, var)\n\nCalculate the magnitude square of vector var. See get_vectors for the options.\n\n\n\n\n\n","category":"function"},{"location":"man/internal/#Batsrus.get_particle_field_aligned_transform","page":"Internal","title":"Batsrus.get_particle_field_aligned_transform","text":"get_particle_field_aligned_transform(b_field, e_field=nothing)\n\nReturn a transformation function that converts particle data to a field-aligned coordinate system.\n\nIf only b_field is provided, the velocity components are decomposed into parallel and perpendicular to the magnetic field. If e_field is also provided, an orthonormal basis (hatmathbfb, hatmathbfe, hatmathbfd) is created, where hatmathbfd propto mathbfB times mathbfE and hatmathbfe = hatmathbfd times hatmathbfb.\n\nThe returned function takes (data, names) and returns (new_data, new_names).\n\n\n\n\n\n","category":"function"},{"location":"man/internal/#Batsrus.get_range-Union{Tuple{BatsrusIDLStructured{2, TV, TX, TW}}, Tuple{TW}, Tuple{TX}, Tuple{TV}} where {TV, TX, TW}","page":"Internal","title":"Batsrus.get_range","text":"Return mesh range of bd.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.get_timeseries-Tuple{AbstractArray, Any}","page":"Internal","title":"Batsrus.get_timeseries","text":" get_timeseries(files::AbstractArray, loc; tstep = 1.0)\n\nExtract plasma moments and EM field from PIC output files at loc with nearest neighbor. Currently only works for 2D outputs. If a single point variable is needed, see interp1d.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.get_var_range-Tuple{BatsrusIDL, Any}","page":"Internal","title":"Batsrus.get_var_range","text":"Return value range of var in bd.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.get_vectors-Tuple{BatsrusIDL, Any}","page":"Internal","title":"Batsrus.get_vectors","text":" get_vectors(bd::BatsrusIDL, var)\n\nReturn a tuple of vectors of var. var can be :B, :E, :U, or any :U followed by an index (e.g. :U0 for species 0, :U1 for species 1, etc.).\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.getascii!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any, IOStream}} where {T, N}","page":"Internal","title":"Batsrus.getascii!","text":"Read ascii format coordinates and data values.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.getbinary!-Union{Tuple{N}, Tuple{T}, Tuple{AbstractArray{T, N}, Any, IOStream}} where {T, N}","page":"Internal","title":"Batsrus.getbinary!","text":"Read binary format coordinates and data values.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.getfilehead-Tuple{IOStream, Batsrus.FileList}","page":"Internal","title":"Batsrus.getfilehead","text":" getfilehead(fileID::IoStream, filelist::FileList) -> NameTuple\n\nObtain the header information from BATSRUS output file of type linked to fileID.\n\nInput arguments\n\nfileID::IOStream: file identifier.\nfilelist::FileList: file information.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.getfiletype-Tuple{AbstractString}","page":"Internal","title":"Batsrus.getfiletype","text":"Obtain file type.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.getvar-Union{Tuple{TV}, Tuple{ndim}, Tuple{BatsrusIDL{ndim, TV}, AbstractString}} where {ndim, TV}","page":"Internal","title":"Batsrus.getvar","text":" getvar(bd::BATS, var::AbstractString) -> Array\n\nReturn variable data from string var. This is also supported via direct indexing. Note that the query variable var must be in lowercase!\n\nExamples\n\nbd[\"rho\"]\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.getview-Union{Tuple{TV}, Tuple{BatsrusIDL{1, TV}, Any}} where TV","page":"Internal","title":"Batsrus.getview","text":"Return view of variable var in bd.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.ibits-Tuple{Any, Any, Any}","page":"Internal","title":"Batsrus.ibits","text":"Logical shifts as the Fortran instrinsic function.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.interp1d-Union{Tuple{TW}, Tuple{TX}, Tuple{TV}, Tuple{BatsrusIDLStructured{2, TV, TX, TW}, AbstractString, AbstractVector{<:AbstractFloat}}} where {TV, TX, TW}","page":"Internal","title":"Batsrus.interp1d","text":" interp1d(bd::BatsrusIDLStructured, var::AbstractString, loc::AbstractVector{<:AbstractFloat})\n\nInterpolate var at spatial point loc in bd.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.interp1d-Union{Tuple{TW}, Tuple{TX}, Tuple{TV}, Tuple{BatsrusIDLStructured{2, TV, TX, TW}, AbstractString, Vector, Vector}} where {TV, TX, TW}","page":"Internal","title":"Batsrus.interp1d","text":" interp1d(bd::BatsrusIDLStructured, var::AbstractString, point1::Vector, point2::Vector)\n\nInterpolate var along a line from point1 to point2 in bd.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.interp2d","page":"Internal","title":"Batsrus.interp2d","text":" interp2d(bd::BatsrusIDL, var::AbstractString, plotrange=[-Inf, Inf, -Inf, Inf],\n\t plotinterval=Inf; kwargs...)\n\nReturn 2D interpolated slices of data var from bd. If plotrange is not set, output data resolution is the same as the original.\n\nKeyword Arguments\n\ninnermask=false: Whether to mask the inner boundary with NaN.\nrbody=1.0: Radius of the inner mask. Used when the rbody parameter is not found in the header.\nuseMatplotlib=true: Whether to Matplotlib (faster) or NaturalNeighbours for scattered interpolation. If true, a linear interpolation is performed on a constructed triangle mesh.\n\n\n\n\n\n","category":"function"},{"location":"man/internal/#Batsrus.interpolate2d_generalized_coords-Union{Tuple{T}, Tuple{T, T, T, Vector{<:AbstractFloat}, Real}} where T<:(AbstractVector)","page":"Internal","title":"Batsrus.interpolate2d_generalized_coords","text":"Perform Triangle interpolation of 2D data W on grid X, Y.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.load-Tuple{AbstractString}","page":"Internal","title":"Batsrus.load","text":" load(filename; npict=1, verbose=false)\n\nRead BATSRUS output files. Stores the npict snapshot from an ascii or binary data file into the arrays of coordinates x and data w.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.meshgrid","page":"Internal","title":"Batsrus.meshgrid","text":"Return the axis range for 2D outputs. See interp2d.\n\n\n\n\n\n","category":"function"},{"location":"man/internal/#Batsrus.meshgrid-Tuple{Any, Any}","page":"Internal","title":"Batsrus.meshgrid","text":"Generating consistent 2D arrays for passing to plotting functions.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.nodeToGlobalBlock-Tuple{Batl, Int32, Any}","page":"Internal","title":"Batsrus.nodeToGlobalBlock","text":"Return global block index for the node.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.order_children!-Tuple{Batl, Int32, Int64, Vector{Int32}}","page":"Internal","title":"Batsrus.order_children!","text":" order_children!(batl::Batl, iNode, iMorton::Int, iNodeMorton_I::Vector{Int32})\n\nRecursively apply Morton ordering for nodes below a root block. Store result into iNodeMortonI and iMortonNodeA using the iMorton index.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.order_tree-Tuple{Batl}","page":"Internal","title":"Batsrus.order_tree","text":" order_tree(batl)\n\nReturn maximum AMR level in the used block and the Morton curve order. Set iNodeMorton_I indirect index arrays according to\n\nroot node order\nMorton ordering for each root node\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.readhead-Tuple{Any}","page":"Internal","title":"Batsrus.readhead","text":"Return BATL header from info file. Currently only designed for 2D and 3D.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.readlogdata-Tuple{AbstractString}","page":"Internal","title":"Batsrus.readlogdata","text":"Read information from log file.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.readtecdata-Tuple{AbstractString}","page":"Internal","title":"Batsrus.readtecdata","text":" readtecdata(file; verbose=false)\n\nReturn header, data and connectivity from BATSRUS Tecplot outputs. Both 2D and 3D binary and ASCII formats are supported.\n\nExamples\n\nfile = \"3d_ascii.dat\"\nhead, data, connectivity = readtecdata(file)\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.readtree-Tuple{Any}","page":"Internal","title":"Batsrus.readtree","text":"Return BATL tree structure.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.rotateTensorToVectorZ-Union{Tuple{T}, Tuple{AbstractMatrix{T}, Any}} where T","page":"Internal","title":"Batsrus.rotateTensorToVectorZ","text":" rotateTensorToVectorZ(tensor::AbstractMatrix, v::AbstractVector) -> SMatrix{3,3}\n\nRotate tensor with a rotation matrix that aligns the 3rd direction with vector, which is equivalent to change the basis from (i,j,k) to (i′,j′,k′) where k′ ∥ vector. Reference: Tensor rotation\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.showhead","page":"Internal","title":"Batsrus.showhead","text":" showhead(file, head)\n\nDisplaying file header information.\n\n\n\n\n\n","category":"function"},{"location":"man/internal/#Batsrus.showhead-Tuple{BatsrusIDL}","page":"Internal","title":"Batsrus.showhead","text":" showhead(data)\n showhead(io, data)\n\nDisplay file information of data.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.slice1d","page":"Internal","title":"Batsrus.slice1d","text":" slice1d(bd, var, icut::Int=1, dir::Int=2)\n\nReturn view of variable var in bd along 1D slice. icut is the index along axis dir. dir == 1 means align with the 2nd (y) axis, dir == 2 means align with the 1st (x) axis.\n\n\n\n\n\n","category":"function"},{"location":"man/internal/#Batsrus.squeeze-Tuple{AbstractArray}","page":"Internal","title":"Batsrus.squeeze","text":"Squeeze singleton dimensions for an array A.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.subsurface-NTuple{4, Any}","page":"Internal","title":"Batsrus.subsurface","text":"subsurface(x, y, data, limits)\nsubsurface(x, y, u, v, limits)\n\nExtract subset of 2D surface dataset in ndgrid format. See also: subvolume.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.subvolume-NTuple{5, Any}","page":"Internal","title":"Batsrus.subvolume","text":"subvolume(x, y, z, data, limits)\nsubvolume(x, y, z, u, v, w, limits)\n\nExtract subset of 3D dataset in ndgrid format. See also: subsurface.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.swaprows!-Tuple{Matrix, Int64, Int64}","page":"Internal","title":"Batsrus.swaprows!","text":"Return matrix X with swapped rows i and j.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.HDF","page":"Internal","title":"Batsrus.HDF","text":"Module for BATSRUS HDF5 file processing.\n\n\n\n\n\n","category":"module"},{"location":"man/internal/#Batsrus.HDF.BatsrusHDF5Uniform","page":"Internal","title":"Batsrus.HDF.BatsrusHDF5Uniform","text":"BATSRUS HDF5 file with uniform Cartesian mesh.\n\n\n\n\n\n","category":"type"},{"location":"man/internal/#Batsrus.HDF.HDF5Common","page":"Internal","title":"Batsrus.HDF.HDF5Common","text":"BATSRUS hdf5 file wrapper.\n\nThe data are stored in blocks, i.e., each field component is stored in a 4D array in the order (iblock, iz, iy, ix). This is a generic wrapper and does not assume grid type, i.e., uniform, stretched nonuniform, or AMR, etc. Classes to handle data with different grids can be derived from this class.\n\n\n\n\n\n","category":"type"},{"location":"man/internal/#Batsrus.HDF.coord2index-Union{Tuple{TF}, Tuple{TI}, Tuple{BatsrusHDF5Uniform{TI, TF}, Int64, Real}} where {TI, TF}","page":"Internal","title":"Batsrus.HDF.coord2index","text":"Return lower corner index.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.HDF.extract_var-Union{Tuple{TF}, Tuple{TI}, Tuple{BatsrusHDF5Uniform{TI, TF}, String}} where {TI, TF}","page":"Internal","title":"Batsrus.HDF.extract_var","text":" extract_var(file::BatsrusHDF5Uniform, var::String; kwargs...)\n\nExtract variable var from HDF5 file.\n\nKeywords\n\nxmin: minimum extracted coordinate in x.\nxmax: maximum extracted coordinate in x.\nstepx: extracted stride in x.\nymin: minimum extracted coordinate in y.\nymax: maximum extracted coordinate in y.\nstepy: extracted stride in y.\nzmin: minimum extracted coordinate in z.\nzmax: maximum extracted coordinate in z.\nstepz: extracted stride in z.\nverbose::Bool=true: display type and size information of output variable.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.HDF.global_slice_to_local_slice-Tuple{BatsrusHDF5Uniform, Int64, OrdinalRange, Int64}","page":"Internal","title":"Batsrus.HDF.global_slice_to_local_slice","text":" global_slice_to_local_slice(file::BatsrusHDF5Uniform, dim, gslc, ib)\n\nConvert global slice gslc to local slice lslc on a given block index ib.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.HDF.prep_extract-Tuple{BatsrusHDF5Uniform}","page":"Internal","title":"Batsrus.HDF.prep_extract","text":" prep_extract(file::BatsrusHDF5Uniform, vmin=-Inf, vmax=Inf, step=1)\n\nGet info for data extraction in 1D.\n\nKeywords\n\nvmin, vmax: requested coordinate range (corner values).\nstep: stride.\n\nReturns:\n\ngslc: global slice.\nvmin_new, vmax_new: adjusted coordinate range (corner values).\nibmin:ibmax: block range.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.HDF.prep_extract_per_block-Tuple{BatsrusHDF5Uniform, Int64, OrdinalRange, Int64}","page":"Internal","title":"Batsrus.HDF.prep_extract_per_block","text":" prep_extract_per_block(file::BatsrusHDF5Uniform, dim, gslc, ib)\n\nGet info for data extraction on a single block.\n\nArguments\n\ngslc: global slice from prep_extract.\nib::Int: block index.\n\nReturns\n\nlslc: range to be used on the current block.\nix0:ix1: index range in the global array.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.HDF.prepslice-Tuple{BatsrusHDF5Uniform}","page":"Internal","title":"Batsrus.HDF.prepslice","text":" prepslice(file::BatsrusHDF5Uniform; dim::Int, vmin, vmax, step=1)\n\nReturn range that covers [vmin, vmax) along dimension dim.\n\nReturns\n\nslc_new: trimed slice. If the object's Nx==1, then 1:1 will be returned.\nxl_new: adjusted lower corner coordinate matching slc_new.start.\nxu_new: adjusted lower corner coordinate matching slc_new.stop.\n\n\n\n\n\n","category":"method"},{"location":"man/internal/#Batsrus.HDF.trimslice-NTuple{4, Any}","page":"Internal","title":"Batsrus.HDF.trimslice","text":" trimslice(start, stop, step, stop_max)\n\nSet slice's start to be nonnegative and start/stop to be within bound. Reverse slicing is not handled.\n\n\n\n\n\n","category":"method"},{"location":"#Batsrus.jl","page":"Home","title":"Batsrus.jl","text":"","category":"section"},{"location":"#Overview","page":"Home","title":"Overview","text":"note: Note\nThis package is still under development, so be careful for any future breaking changes!\n\nBATSRUS and SWMF data reading, converting, visualizing and analyzing in Julia.\n\nThis package provides the following functionalities:\n\nsimulation data reader\nrun log plots\n2D/3D region cut from the whole data\nphase space distribution plots\ninterpolation from unstructured to structured data\ndata format conversion to VTK\nsimulation data visualization\n\nThe ultimate goal is to build a convenient tool of reading and analyzing simulation outputs which is easy to install and easy to use.\n\ntip: Ready to use?\nFeel free to contact the author for any help or collaboration!","category":"section"},{"location":"#Installation","page":"Home","title":"Installation","text":"Install VisAna from the julia REPL prompt with\n\nusing Pkg\nPkg.add(\"Batsrus\")\n\nOr in the Pkg REPL\n\njulia> ]\npkg> add Batsrus","category":"section"},{"location":"#Benchmark","page":"Home","title":"Benchmark","text":"Data loading speed of a 2.4GB 3D binary file, 317MB 3D binary file, and 65KB 2D binary file on Macbook Pro with quad core 2.2 GHz Intel i7 and 16 GB 1600 MHz DDR3:\n\n2.4GB tmax [s] tmean [s]\nJulia 2.73 1.32\nPython 1.35 1.34\nIDL 6.18 6.08\nMATLAB 16.02 10.60\n\n317MB tmean [ms]\nJulia 180.8\nPython 179.5\nIDL 453.5\nMATLAB 698.4\n\n65KB tmean [μs]\nJulia 163.36\nPython 4390.95\nIDL 1970.29\nMATLAB 19273.25\n\nThe Julia, IDL, and MATLAB version all shares the same kernel design. The timings are obtained for Julia v1.3.1, Python 3.7.6 + Numpy 1.18.1, IDL 8.5, and MATLAB R2018b. For dynamic languages with JIT, the first time when function gets executed is also the slowest due to runtime compilation, as can be seen from tmax in the tables. spacepy reaches the same level of performance as Batsruls.jl because of the well-optimized numpy library written in C. However, for small data sizes Batsrus.jl is much faster than packages written in other languages.","category":"section"},{"location":"#Calling-From-Python","page":"Home","title":"Calling From Python","text":"In Python, you can easily take advantage of this package with the aid of JuliaCall or PyJulia.\n\nWith JuliaCall:\n\nfrom juliacall import Main as jl\njl.seval(\"using Batsrus\")\nfile = 'test/example.out'\ndata = Batsrus.load(file)\n\nWith PyJulia:\n\nfrom julia import Batsrus\nfile = 'test/1d__raw_2_t25.60000_n00000258.out'\ndata = Batsrus.load(file)\n\nwarning: Python dependency\nPyPlot package backend may be affected by the settings of PyJulia dependencies. If you want to set it back properly, you need to recompile the PyCall package in Julia.","category":"section"},{"location":"#Developers","page":"Home","title":"Developers","text":"This package inherits the ideas and code structures from its predecessor in IDL (developed by Gábor Tóth) and MATLAB.\n\nBatsrus.jl is developed and maintained by Hongyang Zhou.","category":"section"},{"location":"#Acknowledgments","page":"Home","title":"Acknowledgments","text":"All the nice guys who share their codes!","category":"section"},{"location":"examples/visualization/demo_animate_1d/#demo_line_animation","page":"Line Animation","title":"Line Animation","text":"(Image: Author) (Image: Update time)\n\nThis example shows how to create 1D space line animation from series of SWMF outputs.\n\nVertical line moving at the solar wind speed for reference.\nTwin axes sharing the same x-axis for showing two quantities in one frame.\nTime-dependent title.\n\nusing Batsrus, PyPlot, Printf\n\n\"\"\"\n    animate1d(files::Vector{String}, vars::Vector{String}; kwargs...)\n\nSaving series of plots of `vars` from SWMF output `files`.\n\n# Keywords\n- `filedir::String=\"./\"`: input SWMF file directory.\n- `outdir::String=\"out/\"`: output directory.\n- `output_interval::Int=1`: Timestep interval for output files.\n- `vmin=-1`: plot value lower bound.\n- `vmax=1`: plot value upper bound.\n- `refloc=1e5`: reference vertical line initial location.\n\"\"\"\nfunction animate1d(files::Vector{String}, vars::Vector{String};\n   filedir::String=\"./\", outdir::String=\"out/\", output_interval::Int=1,\n   vmin=-1, vmax=1, refloc=1e5)\n   nfile = length(files)\n   x = let\n      bd = load(joinpath(filedir, files[1]))\n      bd.x[:,1,1]\n   end\n\n   fig = plt.figure(figsize=(12,5), constrained_layout=true)\n   ax = plt.axes(xlim=extrema(x), ylim=(vmin, vmax))\n\n   line, = ax.plot([], [], lw=1)\n   # Move reference line forward in the canvas\n   vl = ax.axvline(0, ls=\"-\", color=\"tab:brown\", lw=1, zorder=10)\n\n   color = \"tab:blue\"\n   ax.set_xlabel(\"x [km]\"; fontsize=14)\n   ax.set_ylabel(var*\" [nT]\"; fontsize=14, color)\n   ax.tick_params(axis=\"y\", labelcolor=color)\n\n   ax2 = ax.twinx()\n   ax2.set_ylim(-600, 0)\n\n   color = \"tab:red\"\n   ax2.set_ylabel(\"Ux [km/s]\"; fontsize=14, color)\n\n   line2, = ax2.plot([], []; color, alpha=0.7)\n   ax2.tick_params(axis=\"y\", labelcolor=color)\n\n\n   for (i, file) in enumerate(files)\n      @info \"$i in $nfile\"\n      outname = outdir*lpad(i, 4, '0')*\".png\"\n      isfile(outname) && continue\n\n      bd = load(joinpath(filedir, file))\n\n      d = bd[vars[1]][:,1]\n      title_str = @sprintf \"t = %4.1f s\" bd.head.time\n      line.set_data(x, d)\n      d2 = bd[vars[2]][:,1]\n      line2.set_data(x, d2)\n\n      ax.set_title(title_str)\n\n      refloc -= output_interval * VSW\n      if refloc <= 0\n         refloc += 1e5\n      end\n      vl.set_xdata([refloc, refloc])\n\n      savefig(outname, bbox_inches=\"tight\", dpi=200)\n   end\n\n   close()\nend\n\n####################\n# Constants\nconst VSW = 500.0  # Solar wind speed, [km/s]\n\n# Data directory\nfiledir = \"./\"\n# Plot variables\nvars = [\"By\", \"uxs1\"]\n\n# Find simulation data\nfiles = let\n   pick_file = file -> startswith(file, \"z\") && endswith(file, \".out\")\n   filter(pick_file, readdir(filedir))\nend\n\nanimate1d(files, vars)\n\n\n\nThis page was generated using DemoCards.jl.","category":"section"},{"location":"man/log/#Development-Log","page":"Log","title":"Development Log","text":"All the workflows here is not restricted to one type of model output. After being familiar with new ideas and new models, one can easily make use of existing samples and create reader of their own. Because of the embarrassing parallelism nature of postprocessing, it is quite easy to take advantage of parallel approaches to process the data.\n\nFor the plotting, streamline tracing and particle tracing, a common problem is the grid and related interpolation process. Now I have FieldTracer.jl and TestParticle.jl designed specifically for these tasks.","category":"section"},{"location":"man/log/#Test-Data","page":"Log","title":"Test Data","text":"If you don't have SWMF data at hand, Batsrus.jl provides some test data for you to begin with.\n\nusing LazyArtifacts\n\ndatapath = artifact\"testdata\" # where you can find multiple test data files\n\nThese are also used in the standard test. These will be automatically downloaded from batsrus_data if you run the package test locally.","category":"section"},{"location":"man/log/#VTK-AMR-Grid-Structure","page":"Log","title":"VTK AMR Grid Structure","text":"vtkOverlappingAMR implements a somewhat strict Berger-Collela AMR scheme:\n\nAll grids are Cartesian.\nGrids at the same level do not overlap.\nThe refinement ratios, RL, between adjacent levels are integer (typically 2 or 4) and uniform within the same level.\nGrid cells are never partially refined; i.e., each cell is refined to four quads in 2D or eight hexahedra in 3D.\n\nOr in other words,\n\nRefinement ratio across levels is constant.\nEach block at levels > 0 need to be covered 100% by one parent block of\n\nprevious level.\n\nSome other restriction about what happens at the boundary.\n\nYou can directly use vtkUniformGridAMR, which does not impose any restrictions. Most filters should work for this class - there just wouldn't be any specialized filters such as the dual-grid contour / clip ones for the vtkOverlappingAMR.\n\nThe vtkAMRInformation documentation consists only of\n\nRefinement ratio between AMR levels\nGrid spacing for each level\nThe file block index for each block parent child information, if requested\n\n(Image: sample_2DAMR) Sample 2D AMR Dataset with two levels and refinement ratio, RL=4. The root level (L0) consists of a single grid shown in black wireframe while the next level (L1) consists of two grids, depicted in green wireframe and red wireframe respectively. The two grids at L1 are projected from the root level to illustrate that the cells underneath are “hidden.”\n\nIn VTK, the collection of AMR grids is stored in a vtkHierarchicalBoxDataSet data-structure. Each grid, G(Li,k), is represented by a vtkUniformGrid data structure where the unique key pair (Li,k) denotes the corresponding level (Li) and the grid index within the level (k) with respect to the underlying hierarchical structure. An array historically known as IBLANK, stored as a cell attribute in vtkUniformGrid, denotes whether a cell is hidden or not. The blanking array is subsequently used by the mapper to hide lower resolution cells accordingly when visualizing the dataset.\n\nTo enable the execution of data queries without loading the entire dataset in memory, metadata information is employed. The metadata stores a minimal set of geometric information for each grid in the AMR hierarchy. Specifically, the AMR metadata, B(Li,k), corresponding to the grid G(Li,k), is represented using a vtkAMRBox object and it consists of the following information:\n\nN={Nx, Ny, Nz} — the cell dimensions of the grid (since the data is cell-centered)\nThe grid spacing at level L, hL={hx,hy,hz}\nThe grid level Li and grid index k\nThe global dataset origin, X=(X0, Y0, Z0), i.e., the minimum origin from all grids in level L0\nThe LoCorner and HiCorner, which describe the low and high corners of the rectangular region covered by the corresponding grid in a virtual integer lattice with the same spacing (h) that covers the entire domain.\n\n(Image: sample_2DAMR)\n\nGiven the metadata information stored in the AMR box of each grid, the refinement ratio at each level can be easily computed using relationship (1) from Table 1. Further, the cartesian bounds the corresponding grid covers and the number of points and cells is also available (see relationships 2-4 in Table 1). Notably, geometric queries such as determining which cell contains a given point, or if a grid intersects a user-supplied slice plane, can be answered using just the metadata.\n\nThere is a vtkAMRDualExtractionFilter, which constructs a dual-mesh (i.e., the mesh constructed by connecting the cell-centers) over the computational domain. If we can directly tell ParaView that the mesh we have is a dual-mesh, then the initial trial with multi-block data may work directly.\n\nAMRGaussianPulseSource\n\nSee Multi-Resolution Rendering with Overlapping AMR for the implementation of C++ reader in VTK.","category":"section"}]
}
